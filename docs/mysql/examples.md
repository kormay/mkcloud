# 示例一
有这样一段SQL

```sql
select distinct(server) from record where type = 'GD0001';
```

其中:  

- record表中的数据大概有2000万条左右 
- 字段type的值为GD0001的记录大概有500万，而这段SQL执行的结果大概有30多条
- type字段上有索引
- 业务上要求server字段的值需要实时求得

在以上条件下，这条SQL语句的执行时间超过一分钟。
不难发现，得到去重后server字段的值是导致性能问题的根本原因。

因为这段SQL语句的筛选条件type字段有索引，所以整个SQL语句的逻辑查询步骤大致如下

1. 通过type索引筛选出符合要求记录的主键字段的标识
2. 通过主键标识定位到表中记录的源数据
3. 拿到字段的值进行distinct去重得到最终的结果。


上面的三个步骤中，最消耗性能的是第二步。
虽然type上有索引，但是type值为GD0001记录有500万条，

在关系数据库中，有一种索引称为覆盖索引，就是为了满足这种优化需求而设计的。
针对这段SQL语句优化的覆盖索引创建语句如下

```sql
create index index_type_server on record(type, server);
```

原sql语句：
```sql
select distinct(server) from record where type = 'GD0001';
```

所有的查询步骤在索引中就能完成，而不用再去源数据表里提取数据，也就是在没建立这个索引时进行查询的第二步被消除了，因此查询的性能极大幅度的得到了提升。
在没建立覆盖索引前，查询的时间需要一分钟以上，在建立索引后，查询的时间下降到几百毫秒的级别。
